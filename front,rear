#include <ros/ros.h>
#include <sensor_msgs/LaserScan.h>
#include <sensor_msgs/PointCloud2.h>
#include <geometry_msgs/Point.h>
#include <visualization_msgs/Marker.h>
#include <std_msgs/Float64.h>
#include <laser_geometry/laser_geometry.h>
#include <vector>
#include <cmath>
#include <limits>
#include <algorithm>

struct Point2D {
    double x;
    double y;
};

class ClusterFollower {
public:
    ClusterFollower(ros::NodeHandle& nh) {
        sub_scan_ = nh.subscribe("/scan", 1, &ClusterFollower::scanCallback, this);
        marker_pub_ = nh.advertise<visualization_msgs::Marker>("/dbscan_lines", 300);
        pub_cloud_ = nh.advertise<sensor_msgs::PointCloud2>("/scan_points", 300);
        pub_speed_ = nh.advertise<std_msgs::Float64>("/commands/motor/speed", 1);
        pub_servo_ = nh.advertise<std_msgs::Float64>("/commands/servo/position", 1);

        eps_ = 0.3;          // 클러스터 간 거리
        min_samples_ = 2;    // 최소 점 수
        follow_speed_ = 900; // 주행 속도
        min_speed_ = 900;    // 인식 안 될 때 속도
        k_yaw_ = 0.3;        // 조향 비율
        max_yaw_ = M_PI / 6; // ±30도 제한
    }

private:
    ros::Subscriber sub_scan_;
    ros::Publisher marker_pub_;
    ros::Publisher pub_cloud_;
    ros::Publisher pub_speed_;
    ros::Publisher pub_servo_;
    laser_geometry::LaserProjection projector_;

    double eps_;
    int min_samples_;
    double follow_speed_;
    double min_speed_;
    double k_yaw_;
    double max_yaw_;

    std::vector<int> dbscan(const std::vector<Point2D>& points) {
        int n = points.size();
        std::vector<int> labels(n, -1);
        int cluster_id = 0;

        auto dist = [](const Point2D& a, const Point2D& b) {
            return std::hypot(a.x - b.x, a.y - b.y);
        };

        for (int i = 0; i < n; i++) {
            if (labels[i] != -1) continue;
            std::vector<int> neighbors;
            for (int j = 0; j < n; j++) {
                if (dist(points[i], points[j]) <= eps_) neighbors.push_back(j);
            }
            if (neighbors.size() < min_samples_) continue;

            cluster_id++;
            labels[i] = cluster_id;
            std::vector<int> seed_set = neighbors;
            for (size_t k = 0; k < seed_set.size(); k++) {
                int j = seed_set[k];
                if (labels[j] != -1) continue;
                labels[j] = cluster_id;

                std::vector<int> j_neighbors;
                for (int m = 0; m < n; m++) {
                    if (dist(points[j], points[m]) <= eps_) j_neighbors.push_back(m);
                }
                if (j_neighbors.size() >= min_samples_)
                    seed_set.insert(seed_set.end(), j_neighbors.begin(), j_neighbors.end());
            }
        }
        return labels;
    }

    void scanCallback(const sensor_msgs::LaserScanConstPtr& scan) {
        std::vector<Point2D> front_points, rear_points;
        double angle = scan->angle_min;

        for (auto r : scan->ranges) {
            if (!std::isfinite(r) || r < 0.13 || r > 0.9) {
                angle += scan->angle_increment;
                continue;
            }

            double x = r * std::cos(angle);
            double y = r * std::sin(angle);

            if (x >= 0.0) front_points.push_back({x, y}); // 전방
            else rear_points.push_back({x, y});           // 후방

            angle += scan->angle_increment;
        }

        if (front_points.empty() && rear_points.empty()) {
            ROS_WARN_THROTTLE(1.0, "No valid points detected — moving straight slowly");
            publishMinimalSpeed(true);
            return;
        }

        // --- PointCloud2 퍼블리시 ---
        sensor_msgs::PointCloud2 cloud;
        projector_.projectLaser(*scan, cloud);
        pub_cloud_.publish(cloud);

        // DBSCAN
        auto front_labels = dbscan(front_points);
        auto rear_labels = dbscan(rear_points);

        // 클러스터 중심 계산
        double target_x = 0.0, target_y = 0.0;
        int front_cnt = 0, rear_cnt = 0;
        double front_x_sum=0, front_y_sum=0, rear_x_sum=0, rear_y_sum=0;

        auto calc_center = [](const std::vector<Point2D>& pts, const std::vector<int>& labels, int max_label, double& x_sum, double& y_sum, int& cnt){
            for(int c=1;c<=max_label;c++){
                double cx=0, cy=0; int count=0;
                for(size_t i=0;i<pts.size();i++){
                    if(labels[i]==c){
                        cx += pts[i].x;
                        cy += pts[i].y;
                        count++;
                    }
                }
                if(count>0){
                    cx/=count; cy/=count;
                    x_sum += cx; y_sum += cy; cnt++;
                }
            }
        };

        if(!front_points.empty()){
            int max_label = *std::max_element(front_labels.begin(), front_labels.end());
            calc_center(front_points, front_labels, max_label, front_x_sum, front_y_sum, front_cnt);
        }

        if(!rear_points.empty()){
            int max_label = *std::max_element(rear_labels.begin(), rear_labels.end());
            calc_center(rear_points, rear_labels, max_label, rear_x_sum, rear_y_sum, rear_cnt);
        }

        // 목표 좌표 계산 (전방 중심 + 후방 가중치)
        if(front_cnt>0) {
            double fx = front_x_sum/front_cnt;
            double fy = front_y_sum/front_cnt;
            double rx = (rear_cnt>0)? rear_x_sum/rear_cnt : 0.0;
            double ry = (rear_cnt>0)? rear_y_sum/rear_cnt : 0.0;

            // 후방 가중치는 작게 (0.2)
            target_x = 0.8*fx + 0.2*rx;
            target_y = 0.8*fy + 0.2*ry;
        } else { // 전방이 없으면 후방만
            target_x = rear_x_sum/rear_cnt;
            target_y = rear_y_sum/rear_cnt;
        }

        double yaw = atan2(target_y, target_x);
        yaw = std::clamp(yaw, -max_yaw_, max_yaw_);
        double steering = k_yaw_ * yaw;

        // 퍼블리시
        std_msgs::Float64 speed_msg, servo_msg;
        speed_msg.data = follow_speed_;
        servo_msg.data = steering;
        pub_speed_.publish(speed_msg);
        pub_servo_.publish(servo_msg);

        ROS_INFO_THROTTLE(1.0, "Target: x=%.2f y=%.2f, yaw=%.2f, steering=%.2f", target_x, target_y, yaw, steering);
    }

    void publishMinimalSpeed(bool move_forward = true){
        std_msgs::Float64 speed_msg, servo_msg;
        speed_msg.data = min_speed_;
        servo_msg.data = 0.57165;
        pub_speed_.publish(speed_msg);
        pub_servo_.publish(servo_msg);
    }
};

int main(int argc, char** argv){
    ros::init(argc, argv, "cluster_follower");
    ros::NodeHandle nh;
    ClusterFollower node(nh);
    ros::spin();
    return 0;
}
